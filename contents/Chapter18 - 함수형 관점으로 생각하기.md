# 함수형 관점으로 생각하기
지금까지 이 책에서 **함수형**이라는 용어를 자주 언급했다. 람다, 일급 함수와 관련이 있으며 때로는 객체 변화를 제한하는것이 함수형과 밀접한 관련을 갖는다.  
함수형을 적용하면 어떤점이 좋은지 이번 장에서 살펴본다.
## 18.1 시스템 구현과 유지보수
함수형 프로그래밍이 제공하는 부작용 없음(no side effect)과 불변성(immutability)이라는 개념은 시스템의 유지보수에 큰 도움을 준다.
#### 공유된 가변되이터
변수가 예상하지 못한 값을 갖는 이유는 결국 우리가 유지보수하는 시스템의 여러 메서드에서 공유된 가변 데이터 구조를 읽고 갱신하기 때문이다.    
어떤 자료구조도 바꾸지 않는 시스템은 예상치 못하게 자료구조의 값이 바뀔 일이 없으니 당연히 유지보수가 쉽다.   
자신을 포함하는 클래스의 상태와 다른 객체의 상태를 바꾸지 않으며 return 문을 통해서만 결과를 반환하는 메서드를 **순수 메서드** 혹은 **부작용 없는 메서드**라고 부른다.  

여기서 부작용이란 함수 내에 포함되지 못한 기능으로, 예시는 다음과 같다.
* 자료구조를 고치거나 필드에 값을 할당(setter 메서드 같은 생성자 이외의 초기화 동작)
* 예외 발생
* 파일에 쓰기 등의 I/O 동작 수행  

**불변 객체를 이용해 부작용을 없애는 방법**도 있다. 불변 객체는 인스턴스화한 다음에는 상태를 바꿀 수 없으므로 스레드 안전성을 제공한다.
부작용 없는 시스템의 개념은 함수형 프로그래밍에서 유래되었다. 먼저 함수형 프로그래밍의 기반을 이루는 개념인 **선언형 프로그래밍**을 살펴보자.

#### 선언현  프로그래밍
프로그램으로 시스템을 구현하는 방식은 크게 **‘어떻게’** 와 **‘무엇을’** 로 구분할 수 있다. 먼저, ‘어떻게’에 집중하는 방식은 고전의 객체지향에서 이용하는 방식으로 명령형 프로그래밍이라고 부르기도 한다.
```java
//리스트에서 가장 비싼 트래잭션 구하기 
for (Transaction t: transactions.subList(1, transactions.size())) {
    if (t.getValue() > mostExpensive.getValue()) {
        mostExpensive = t;
    }
}
```
‘어떻게’가 아닌 **‘무엇을’** 에 집중하는 방식은 4장과 5장에서 스트림 API를 이용하는 방법으로 적용할 수 있다. 선언형 프로그래밍은 문제 자체가 코드로 명확하게 드러난다는 장점이 있다.
```java
Optional<Transaction> mostExpensive = transactions.stream().max(comparing(Transaction::getValue));
```
이와 같은 구현 방식을 **내부 반복** 이라고 한다. 질의문 자체를 어떻게 푸는지 명확하게 보여준다는 것이 내부 반복 프로그래밍의 장점이다.

#### 왜 함수형 프로그래밍인가?
함수형 프로그래밍은 선언형 프로그래밍과 부작용을 멀리하기 때문에 더 쉽게 시스템을 구현하고 유지보수할 수 있다. 이전에 학습했던 람다 표현식과 스트림은 함수형 프로그래밍의 특징을 잘 보여준다.

## 18.2 함수형 프로그래밍이란 무었인가?
함수형 프로그래밍에서 ***함수** 란 수학적인 함수와 같다. 즉, 함수는 0개 이상의 인수를 가지며, 한 개 이상의 결과를 반환하지만 _부작용이 없어야 한다_.  
<sup>함수형이라는 단어는 수학의 함수처럼 부작용이 없는을 의미한다</sup>  
**함수 그리고 if-then-else 등의 수학적 표현만 사용** 하는 방식을 순수 함수형 프로그래밍이라고 하고, **시스템의 다른 부분에 영향을 미치지 않는다면 내부적으로는 함수형이 아닌 기능도 사용 하는 방식**을 함수형 프로그래밍이라 한다.
#### 함수형 자바
자바로는 완벽한 순수 함수형 프로그래밍을 구현하기 어렵다. 하지만 시스템의 컴포넌트가 순수한 함수형인 것처럼 동작하도록 코드를 구현할 수 있다. 자바에서 구현할 것은 순수 함수형이 아닌 **함수형 프로그램**이다. 실제 부작용이 있지만 아무도 이를 보지못하게 함으로써 함수형을 달성할 수 있다.

함수나 메서드는 지역 변수만을 변경해야 함수형이라 할 수 있다. 그리고 함수나 메서드에서 참조하는 객체가 있다면 그 객체는 불변 객체여야 한다. 또한, 함수형이라면 **함수나 메서드가 어떤 예외도 일으키지 않아야** 한다. 예외가 발생할 수 있는 경우엔 `Optional<T>` 를 이용함으로써 연산의 수행 여부를 확인할 수 있다.
#### 참조 투명성
‘부작용을 감춰야 한다’라는 제약은 참조 투명성이라는 개념으로 귀결된다. 즉, 같은 인수로 함수를 호출했을 때 항상 같은 결과를 반환한다면 참조적으로 투명한 함수라고 할 수 있다. 따라서, `Random.nextInt`는 함수형이 될 수 없다.  
자바에는 참조 투명성과 관련한 작은 문제가 있다. List를 반환하는 메서드를 두 번 호출한다고 가정할 때, 두 번의 호출 결과로 같은 요소를 포함하지만 서로 다른 메모리 공간에 생성된 리스트를 참조할 것이다. 그렇기 때문에 결과 리스트가 가변 객체라면 이 메서드는 참조적으로 투명한 메서드가 아니라는 결론이 나오게 되는 것이다.   
만약, 결과 리스트를 (불변의) 순수값으로 사용할 것이라면 두 리스트가 같은 객체라고 볼 수 있으므로 이 때는 이 메서드가 참조적으로 투명하다고 간주할 수 있다. **함수형 코드에서는 이런 함수를 참조적으로 투명한 것으로 간주한다.**

참조 투명성은 다음과 같은 장점이 있다.
* 프로그램 이해에 큰 도움을 준다.
* 오래 걸리는 연산에 대해 기억화(memorization) 또는 캐싱(caching)을 통해 최적화할 수 있다. 

#### 객체지향 프로그래밍과 함수형 프로그래밍 
객체지향 프로그래밍과 함수형 프로그래밍은 반대되는 속성을 가진다.

객체지향 프로그래밍은 모든 것을 객체로 간주하며, 프로그램이 객체의 필드를 갱신하고, 메서드를 호출하여 관련 객체를 갱신하는 방식으로 동작한다. 반대로, 함수형 프로그래밍은 참조적 투명성을 중요시 한다. 즉, 변화를 허용하지 않는 방식이다.

실제로 자바 프로그래머는 이 두 가지 형식을 혼합하여 사용한다.

## 18.3 재귀와 반복
순수 함수형 프로그래밍 언어에서는 while, for와 같은 반복문을 포함하지 않는다. 이러한 반복문 때문에 변화가 자연스럽게 코드에 스며들 수 있기 때문이다. while의 경우, 무한루프를 방지하기 위해 조건을 계속 갱신해줘야 한다. 함수형 프로그래밍에서는 변화를 알아차리지만 못하면 괜찮다고 했으므로 지역 변수는 자유롭게 갱신할 수 있다.
```java
Iterator<Apple> it = apples.iterator();
while (it.hasNext()) {
    Apple apple = it.next();
}
```
위 코드에서 호출자는 변화를 확인할 수 없으므로 아무 문제가 없지만, 다음 코드는 문제가 될 수 있다.
```java
public void searchForGold(List<String> l, Stats stats) {
    for(String s: l) {
        if("gold".equals(s)) {
            stats.incrementFor("gold");
        }
    }
}
```
루프의 내부에서 프로그램의 다른 부분과 공유되는 stats객체의 상태를 변화시키므로 함수형과 상충하는 부작용이 발생한다.

이론적으로 반복을 이용하는 모든 프로그램은 재귀로도 구현할 수 있는데 재귀를 이용하면 변화가 일어나지 않는다. 재귀를 이용하면 루프마다 갱신되는 반복 변수를 제거할 수 있다.
효율성 측면에서 살펴보면, 함수형 프로그래밍의 장점이 분명 있긴 하지만 무조건 반복보다 재귀가 좋다고 할 수 있을까?  
일반적으로 반복코드보다 재귀 코드가 더 비싸다. 함수를 호출할 때마다 호출 스택에 각 호출시 생성되는 정보를 저장할 새로운 스택 프레임이 만들어지므로 메모리 사용량이 증가하기 때문이다.   
함수형 언어에서는 **꼬리 호출 최적화**라는 해결책을 제공한다.
> 함수형 언어에서는 재귀호출 시 꼬리재귀에 대하여 **꼬리 호출 최적화(tail-call optimization, CTO)**라는 해결책을 제공한다. CTO는 컴파일 시 하나의 스택 프레임으로 재활용하도록 하는 최적화이며, 속도의 손실또한 없다. 안타깝게도 현재 자바에서는 CTO를 지원하지 않는다. 하지만 이후 CTO를 지원하도록 발전될 수 있는 컴파일러를 위해 재귀 코드가 있다면 꼬리 재귀적으로 작성하는 것이 좋다(스칼라와 그루비와 같은 최신 JVM언어는 CTO를 지원한다).

```java
static long factorialTailRecursive(long n) {
    return factorialHelper(1, n);
}
static long factorialHelper(long acc, long n) {
    return n == 1 ? acc : factorialHelper(acc * n, n-1);
}
```
factorialHelper에서 재귀 호출이 가장 마지막에서 이루어지므로 꼬리 재귀다. 꼬리 재귀는 컴파일러가 하나의 스택 프레임을 재활용할 가능성이 생긴다. 결과적으로, 순수 함수형을 유지하면서도 유용성뿐 아니라 효율성까지 두 마리의 토끼를 모두 잡을 수 있다.

결론적으로 자바 9에서는 반복을 스트림으로 대체해서 변화를 피할 수 있고, 재귀로 바꿈으로써 더 간결하고 부작용 없는 알고리즘을 만들 수 있다.
